[
  {
    "title": "",
    "image": "",
    "tags": [],
    "data": [
      { "type": "text", "content": "" },
      { "type": "link", "content": "" },
      { "type": "image", "content": "" }
    ]
  },
  {
    "title": "В чем разница между let, var и const?",
    "tags": [],
    "data": [
      {
        "type": "text",
        "content": "Переменная var является глобальной, когда объявлена вне какой-либо функции. Это означает, что любая переменная, объявленная через var вне блока функции, доступна для использования во всем окне."
      },
      { "type": "text", "content": "Переменные var могут быть объявлены повторно." },
      {
        "type": "text",
        "content": "Поднятие var. Поднятие - механизм в JavaScript, по которому переменные и объявления функций перемещаются в верхнюю часть своей области видимости, прежде чем начнется выполнение кода. Обращение к переменной var до ее объявления вернет undefined, а обращение к переменной let или const до их объявления вызовет ReferenceError."
      },
      { "type": "text", "content": "Переменная let имеет блочную область видимости." },
      {
        "type": "text",
        "content": "Переменные let могут быть обновлены, но не объявлены повторно."
      },
      { "type": "text", "content": "Константы const аналогичны let, но их нельзя обновлять." }
    ]
  },
  {
    "title": "Чем тип number отличается от bigint?",
    "tags": [],
    "data": [
      {
        "type": "text",
        "content": "Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754, который также называют «числа с плавающей точкой двойной точности» ( double precision floating point numbers )."
      },
      {
        "type": "text",
        "content": "BigInt числа дают возможность работать с целыми числами произвольной длины. Они нужны достаточно редко и используются в случаях, когда необходимо работать со значениями более чем 2^53 или менее чем -2^53."
      },
      { "type": "link", "content": "https://learn.javascript.ru/number#netochnye-vychisleniya" },
      { "type": "link", "content": "https://learn.javascript.ru/bigint" }
    ]
  },
  {
    "title": "Почему 0.1 + 0.2 в JavaScript не равно 0.3?",
    "tags": [],
    "data": [
      {
        "type": "text",
        "content": "Число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей. Но дроби, такие как 0.1, 0.2, которые выглядят довольно просто в десятичной системе счисления, на самом деле являются бесконечной дробью в двоичной форме."
      },
      {
        "type": "text",
        "content": "Другими словами, что такое 0.1? Это единица делённая на десять — 1/10, одна десятая. В десятичной системе счисления такие числа легко представимы, по сравнению с одной третьей: 1/3, которая становится бесконечной дробью 0.33333(3)."
      },
      {
        "type": "text",
        "content": "Ошибка в точности вычислений для чисел с плавающей точкой сохраняется в любом другом языке, где используется формат IEEE 754, включая PHP, Java, C, Perl, Ruby."
      },
      { "type": "link", "content": "https://learn.javascript.ru/number#netochnye-vychisleniya" }
    ]
  },
  {
    "title": "Какие есть типы данных в JavaScript?",
    "tags": [],
    "data": [
      {
        "type": "text",
        "content": "Всего cтандарт ECMAScript определяет 9 типов ( 6 из них являются приметивами ):"
      },
      {
        "type": "list",
        "content": [
          "Undefined (Неопределённый тип) : typeof instance === \"undefined\"",
          "Boolean (Булев, Логический тип) : typeof instance === \"boolean\"",
          "Number (Число) : typeof instance === \"number\"",
          "String (Строка) : typeof instance === \"string\"",
          "BigInt : typeof instance === \"bigint\"",
          "Symbol (в ECMAScript 6) : typeof instance === \"symbol\""
        ]
      },
      {
        "type": "list",
        "content": [
          "Null (Null тип ) : typeof instance === \"object\". Специальный примитив, используемый не только для данных но и в качестве указателя на финальную точку в цепочке прототипов.",
          "Object (Объект) : typeof instance === \"object\". Простая структура, используемая не только для хранения данных, но и для создания других структур, где любая структура создаётся с использованием ключевого слова new: new Object, new Array, new Map, new Set, new WeakMap, new WeakSet, new Date и множество других структур.",
          "Function : typeof instance === \"function\". Специальный случай, упрощающий определение типа для Функций, несмотря на то, что все функции конструктивно унаследованы от Object."
        ]
      },
      {
        "type": "link",
        "content": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures"
      }
    ]
  },
  {
    "title": "Какая разница в подключении скриптов async, defer?",
    "tags": [],
    "data": [
      {
        "type": "text",
        "content": "Скрипты поочередно скачиваются и выполняются и это может заблокировать загрузку html."
      },
      {
        "type": "text",
        "content": "Скрипты с атрибутом async грузятся асинхронно и выполняются сразу после загрузки."
      },
      {
        "type": "text",
        "content": "Скрипты с атрибутом defer не блокируют загрузку html, грузятся в заданном порядке, выполняются только после загрузки html но до события DOMContentLoaded."
      },
      {
        "type": "text",
        "content": "Атрибут defer будет проигнорирован, если в теге <script> нет src."
      }
    ]
  },
  {
    "title": "Для чего нужно ключевое слово new?",
    "tags": ["new"],
    "data": [
      { "type": "text", "content": "Применяется для вызова функции конструктора." },
      {
        "type": "text",
        "content": "Если написать new 'str' и тд то получится ошибка TypeError is not a constructor."
      },
      {
        "type": "text",
        "content": "Возвращается неявно созданный this из функции конструктора или если был сделан return объекта, то вернется этот объект."
      }
    ]
  },
  {
    "title": "Какие вы знаете HTTP заголовки?",
    "tags": [],
    "data": [
      {
        "type": "text",
        "content": "Когда браузер запрашивает ресурс с сервера, он использует HTTP. Этот запрос включает набор пару ключ-значение, содержащих такую информацию, как версия браузера или форматы файлов, которые он понимает. Эти пары называются заголовками запросов."
      },
      {
        "type": "text",
        "content": "Сервер отвечает запрашиваемым ресурсом, но также отправляет заголовки ответа, содержащие информацию о ресурсе или самом сервере."
      },
      {
        "type": "text",
        "content": "Strict-Transport-Security. Этот заголовок говорит браузеру, что вы не хотите использовать HTTP-запросы, и тогда он автоматически применит те же запросы к такому же источнику с защищенным соединением. Если вы попытаетесь открыть такой же URL через HTTP, браузер снова будет использовать HTTPS и перенаправит пользователя."
      },
      {
        "type": "text",
        "content": "Content-Security-Policy. Вы можете установить свой набор правил CSP. Он предлагает детальные способы определения того, какие ресурсы и действия разрешены на вашем сайте. Вы можете, например, указать, какие скрипты должны выполняться или откуда загружать изображения. Если что-то не разрешено, браузер блокирует это действие и предотвращает потенциальные атаки на ваш сайт."
      },
      {
        "type": "text",
        "content": "Cache-Control. Передача данных сохраняется, и файлы могут использоваться из кэша браузера в течение определенного количества секунд (max-age). Браузеры должны повторно проверять кэшированные ресурсы по истечении этого периода времени."
      },
      {
        "type": "text",
        "content": "Accept-Encoding. Указывает какие алгоритмы сжатия могут использоваться для снижения количества передаваемых данных."
      },
      {
        "type": "text",
        "content": "Feature-Policy. С его помощью вы можете указать, какие функции разрешены, и ограничить всплывающие диалоговые окна с разрешениями, которые могут быть вызваны сторонним кодом, исполняемым на вашем сайте."
      },
      { "type": "link", "content": "https://developer.mozilla.org/ru/docs/Web/HTTP/Headers" }
    ]
  },
  {
    "title": "Напишите функцию которая принимает функцию, каррирует ее и возвращает другую функцию.",
    "image": "7jc57l44vy.jpg",
    "tags": [],
    "data": [
      {
        "type": "text",
        "content": "Каррирование - это трансформация, которая превращает вызов f(a, b, c) в f(a)(b)(c). В JavaScript реализация обычно позволяет вызывать функцию обоими вариантами: либо нормально, либо возвращает частично применённую функцию, если количество аргументов недостаточно."
      },
      { "type": "image", "content": "adccg8k0gf.jpg" }
    ]
  },
  {
    "title": "Напишите функцию которая суммирует числа и вызывается в таком виде: sum(a)(b, c, d)(e, f)(g)...(z)().",
    "tags": [],
    "data": [{ "type": "image", "content": "4gxvi4sfvp.jpg" }]
  },
  {
    "title": "Чем отличается императивный стиль программирования от декларативного?",
    "tags": [],
    "data": [
      {
        "type": "text",
        "content": "Императивный подход отвечает на вопрос \"как?\". Это описание того, как ты делаешь что-то."
      },
      {
        "type": "text",
        "content": "Декларативный подход отвечает на вопрос \"что?\". Это описание того, что ты делаешь."
      },
      {
        "type": "text",
        "content": "Важно понять, что многие, если не все, декларативные подходы имеют определённый слой императивных абстракций."
      },
      {
        "type": "link",
        "content": "https://tproger.ru/translations/imperative-declarative-programming-concepts/"
      }
    ]
  },
  {
    "title": "Чем отличается ООП стиль программирования от функционального?",
    "tags": [],
    "data": [
      {
        "type": "text",
        "content": "Объектно-ориентированное программирование и функциональное программирование преследуют одну и ту же цель — разрабатывать гибкие программы, которые легко понять и которые не содержат ошибок. Но они основаны на разных подходах."
      },
      {
        "type": "text",
        "content": "ООП - это парадигма, основанная на идее «объектов», содержащих данные в форме полей, часто называемых атрибутами; и код в форме процедур, часто называемых методами. Объектно-ориентированное программирование утверждает, что упрощает понимание того, как работает программа, объединяя данные и связанное с ними поведение в одном месте ( называемом «объектом» )."
      },
      {
        "type": "text",
        "content": "Объектно-ориентированное программирование основывается на четырех ключевых принципах:"
      },
      {
        "type": "list",
        "content": [
          "- абстракция (акцент на главном и скрытие ненужных деталей);",
          "- наследование (определение одного класса с точки зрения другого);",
          "- полиморфизм (объединение элементов для создания новой сущности);",
          "- инкапсуляция: ( позволяет скрыть несвязанные данные от пользователей и предотвращает несанкционированный доступ );"
        ]
      },
      {
        "type": "text",
        "content": "FP — это процесс создания программного обеспечения путем составления чистых функций. Все объекты неизменяемы, а это означает, что однажды созданное не может быть изменено. Функциональное программирование утверждает, что данные и поведение — разные вещи и для ясности их следует разделять."
      },
      { "type": "text", "content": "FP основывается на шести концепциях:" },
      {
        "type": "list",
        "content": [
          "- функции высшего порядка (HOF);",
          "- чистота;",
          "- рекурсия;",
          "- ссылочная прозрачность;",
          "- строгая и ленивая оценка;",
          "- системы типов;"
        ]
      },
      {
        "type": "link",
        "content": "https://bestprogrammer.ru/programmirovanie-i-razrabotka/chto-vybrat-funktsionalnoe-programmirovanie-ili-oop"
      }
    ]
  },
  {
    "title": "Что такое констекст в JavaScript?",
    "tags": [],
    "data": [
      {
        "type": "text",
        "content": "Контекст выполнения (execution context) — это, если говорить упрощённо, концепция, описывающая окружение, в котором производится выполнение кода на JavaScript. Код всегда выполняется внутри некоего контекста."
      },
      { "type": "text", "content": "В JavaScript существует три типа контекстов выполнения." },
      {
        "type": "text",
        "content": "Глобальный контекст выполнения. Это базовый, используемый по умолчанию контекст выполнения. Если некий код находится не внутри какой-нибудь функции, значит этот код принадлежит глобальному контексту. Глобальный контекст характеризуется наличием глобального объекта, которым, в случае с браузером, является объект window, и тем, что ключевое слово this указывает на этот глобальный объект. В программе может быть лишь один глобальный контекст."
      },
      {
        "type": "text",
        "content": "Контекст выполнения функции. Каждый раз, когда вызывается функция, для неё создаётся новый контекст. Каждая функция имеет собственный контекст выполнения. В программе может одновременно присутствовать множество контекстов выполнения функций."
      },
      {
        "type": "text",
        "content": "Контекст выполнения функции eval. Код, выполняемый внутри функции eval, также имеет собственный контекст выполнения."
      },
      { "type": "link", "content": "https://habr.com/ru/company/ruvds/blog/422089/" }
    ]
  }
]
